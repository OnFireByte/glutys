package glutys

import (
	"fmt"
	"net/http"
	"reflect"
	"runtime"
	"strconv"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/onfirebyte/glutys/pkg/util"
)

type Middleware func(next http.Handler) http.Handler

func (g *Builder) buildRouter() string {
	routes := g.routes
	f := NewFilePath(g.GeneratePath)

	f.HeaderComment("This file is generated by glutys. DO NOT EDIT.")

	pathMap := map[Code]Code{}

	for path, procedures := range routes {
		pathMap[Lit(path)] = Id(HandlerName(path))
		for i, procedure := range procedures {
			// print function arg types
			fnValue := reflect.ValueOf(procedure)
			fnType := fnValue.Type()
			argNum := fnType.NumIn()
			argTypes := make([]reflect.Type, argNum)

			argTSTypes := []string{}

			for i := 0; i < argNum; i++ {
				argTypes[i] = fnType.In(i)
				_, exist := g.ContextTypes[argTypes[i]]
				if !exist {
					tsFile, tsType := g.Converter.ParseType(NoDot(path), reflect.New(argTypes[i]).Elem().Interface())
					g.tsFile += tsFile
					argTSTypes = append(argTSTypes, tsType)
				}
			}

			// print function return types
			retNum := fnType.NumOut()
			returnTypes := make([]reflect.Type, retNum)
			retTSType := ""
			for i := 0; i < retNum; i++ {
				returnTypes[i] = fnType.Out(i)
			}

			tsFile, tsType := g.Converter.ParseType("", reflect.New(returnTypes[0]).Elem().Interface())
			g.tsFile += tsFile
			retTSType = tsType

			argTS := []string{}
			for i, argTSType := range argTSTypes {
				argTS = append(argTS, fmt.Sprintf("arg%d: %s", i, argTSType))
			}

			g.tsMethods += fmt.Sprintf("\t\"%s\": (%s) => Promise<%s>;\n", path, strings.Join(argTS, ", "), retTSType)

			// check if function is middleware
			isMiddleware := false
			if argNum == 1 &&
				argTypes[0].String() == "http.Handler" &&
				retNum == 1 &&
				returnTypes[0].String() == "http.Handler" {
				isMiddleware = true
			}

			// isProperFunc := true

			if isMiddleware {
				fmt.Println("Middleware")
				continue
			}

			if len(procedures)-1 != i {
				panic("Handler must be last in the list")
			}

			if retNum > 2 {
				panic("Handler must be either void or return only one value with optional error")
			}

			if retNum == 2 && returnTypes[1].String() != "error" {
				panic("Handler must be either void or return only one value with optional error")
			}

			// generate handler function

			_ = generateHandlerFunction(f, fnValue, argTypes, returnTypes, path, g)

		}

	}

	f.Type().Id("HandlerFunc").Func().Params(
		Qual("net/http", "ResponseWriter"),
		Op("*").Qual("net/http", "Request"),
		Op("*").Qual("github.com/onfirebyte/glutys", "RequestBody"),
	)

	f.Var().Id("pathMap").Op("=").Map(String()).Id("HandlerFunc").Values(Dict(pathMap))

	f.Func().Id("RouteHandler").Params(Id("w").Qual("net/http", "ResponseWriter"), Id("r").Op("*").Qual("net/http", "Request")).Block(
		Id("w").Dot("Header").Call().Dot("Set").Call(Lit("Content-Type"), Lit("application/json")),
		// parse body
		Id("body").Op(":=").Qual("github.com/onfirebyte/glutys", "RequestBody").Values(),
		Id("err").Op(":=").Qual("encoding/json", "NewDecoder").Call(Id("r").Dot("Body")).Dot("Decode").Call(Op("&").Id("body")),
		If(Id("err").Op("!=").Nil()).Block(
			Id("response").Op(":=").Map(String()).Interface().Values(Dict{
				Lit("error"): Lit("Bad Request"),
				Lit("msg"):   Lit("Invalid JSON"),
			}),
			Id("w").Dot("WriteHeader").Call(Qual("net/http", "StatusBadRequest")),
			Qual("encoding/json", "NewEncoder").Call(Id("w")).Dot("Encode").Call(Id("response")),
		),

		// get handler
		List(Id("handler"), Id("ok")).Op(":=").Id("pathMap").Index(Id("body").Dot("Method")),
		If(Op("!").Id("ok")).Block(
			Id("response").Op(":=").Map(String()).Interface().Values(Dict{
				Lit("error"): Lit("Bad Request"),
				Lit("msg"):   Lit("Invalid method"),
			}),
			Id("w").Dot("WriteHeader").Call(Qual("net/http", "StatusBadRequest")),
			Qual("encoding/json", "NewEncoder").Call(Id("w")).Dot("Encode").Call(Id("response")),
		),
		Id("handler").Call(Id("w"), Id("r"), Op("&").Id("body")),
	)

	return f.GoString()
}

func generateHandlerFunction(
	f *File,
	fnValue reflect.Value,
	argTypes []reflect.Type,
	returnTypes []reflect.Type,
	path string,
	g *Builder,
) any {
	blocks := []Code{}

	argPos := 0
	argVars := []string{}
	for i, argType := range argTypes {
		_, exist := g.ContextTypes[argType]

		if exist {

			contextParser := g.ContextParsers[argType]
			contextParserValue := reflect.ValueOf(contextParser)
			contextParserType := contextParserValue.Type()
			retTypeName := contextParserType.Out(0).Name()

			hasErr := reflect.TypeOf(contextParser).NumOut() == 2

			argName := retTypeName + strconv.Itoa(i)
			argVars = append(argVars, argName)
			identifiers := []Code{Id(argName)}
			if hasErr {
				identifiers = append(identifiers, Id("err"+argName))
			}

			fnFullName := runtime.FuncForPC(contextParserValue.Pointer()).Name()
			fnNameSplit := strings.Split(fnFullName, ".")
			fnPkgPath := strings.Join(fnNameSplit[:len(fnNameSplit)-1], ".")
			fnName := fnNameSplit[len(fnNameSplit)-1]

			marshaled := List(identifiers...).Op(":=").Qual(fnPkgPath, fnName).Call(
				Id("r"),
			)
			blocks = append(blocks, marshaled)

			if hasErr {
				blocks = append(blocks, If(Id("err"+argName).Op("!=").Nil()).Block(
					Id("response").Op(":=").Map(String()).Interface().Values(Dict{
						Lit("error"): Lit("Invalid Context"),
						Lit("msg"):   Id("err" + argName).Dot("Error").Call(),
					}),
					Id("w").Dot("WriteHeader").Call(Qual("net/http", "StatusBadRequest")),
					Qual("encoding/json", "NewEncoder").Call(Id("w")).Dot("Encode").Call(Id("response")),
					Return(),
				))
			}

		} else {

			argName := PublicToCamelCase(argType.Name()) + strconv.Itoa(i)
			argVars = append(argVars, argName)

			var varDeclare *Statement
			if argType.PkgPath() == "" {
				varDeclare = Var().Id(argName).Add(Id(argType.Name()))
			} else {
				varDeclare = Var().Id(argName).Add(Qual(argType.PkgPath(), argType.Name()))
			}

			marshaled := Id("err"+argName).Op(":=").Qual("encoding/json", "Unmarshal").Call(
				Id("body").Dot("Args").Index(Lit(argPos)),
				Op("&").Id(argName),
			)

			ifErr := If(Id("err"+argName).Op("!=").Id("nil")).Block(
				Id("response").Op(":=").Map(String()).Interface().Values(Dict{
					Lit("error"): Lit("Invalid JSON"),
					Lit("msg"):   Id("err" + argName).Dot("Error").Call(),
				}),
				Id("w").Dot("WriteHeader").Call(Qual("net/http", "StatusBadRequest")),
				Qual("encoding/json", "NewEncoder").Call(Id("w")).Dot("Encode").Call(Id("response")),
				Return(),
			)

			blocks = append(blocks, varDeclare, marshaled, ifErr)
			argPos++

		}
	}

	callIdentifiers := []Code{
		Id("res"),
	}

	hasErr := len(returnTypes) == 2
	if hasErr {
		callIdentifiers = append(callIdentifiers, Id("err"))
	}

	fnFullName := runtime.FuncForPC(fnValue.Pointer()).Name()
	fnNameSplit := strings.Split(fnFullName, ".")
	fnPkgPath := strings.Join(fnNameSplit[:len(fnNameSplit)-1], ".")
	fnName := fnNameSplit[len(fnNameSplit)-1]

	fnArgNameIds := []Code{}
	for _, argVar := range argVars {
		fnArgNameIds = append(fnArgNameIds, Id(argVar))
	}

	call := List(callIdentifiers...).Op(":=").Qual(fnPkgPath, fnName).Call(fnArgNameIds...)

	blocks = append(blocks, call)

	if hasErr {
		blocks = append(blocks, If(Id("err").Op("!=").Nil()).Block(
			Id("w").Dot("WriteHeader").Call(Qual("net/http", "StatusBadRequest")),
			Qual("encoding/json", "NewEncoder").Call(Id("w")).Dot("Encode").Call(
				Map(String()).Interface().Values(Dict{
					Lit("error"): Lit("Bad Request"),
					Lit("msg"):   Id("err").Dot("Error").Call(),
				}),
			),
			Return(),
		))
	}

	blocks = append(blocks,
		Id("w").Dot("WriteHeader").Call(Qual("net/http", "StatusOK")),
		Qual("encoding/json", "NewEncoder").Call(Id("w")).Dot("Encode").Call(
			Id("res")),
		Return())

	c := f.Func().Id(HandlerName(path)).
		Params(
			Id("w").Qual("net/http", "ResponseWriter"),
			Id("r").Op("*").Qual("net/http", "Request"),
			Id("body").Op("*").Qual("github.com/onfirebyte/glutys", "RequestBody")).
		Block(
			blocks...,
		)
	return c
}

func PublicToCamelCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(string(s[0])) + s[1:]
}

func HandlerName(path string) string {
	pathSlice := strings.Split(path, ".")
	for i, p := range pathSlice {
		pathSlice[i] = util.CamelCaseToPublic(p)
	}
	return strings.Join(pathSlice, "") + "Handler"
}

func NoDot(path string) string {
	pathSlice := strings.Split(path, ".")
	for i, p := range pathSlice {
		pathSlice[i] = util.CamelCaseToPublic(p)
	}
	return strings.Join(pathSlice, "")
}
